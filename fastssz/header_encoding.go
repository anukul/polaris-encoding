// Code generated by fastssz. DO NOT EDIT.
// Hash: 18a91297cb238a2718f1521010a4a3d75c7b1435a7f50b3748bd9d2866c7f5d7
// Version: 0.1.3
package fastssz

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Header object
func (h *Header) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the Header object to a target array
func (h *Header) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(608)

	// Field (0) 'ParentHash'
	if size := len(h.ParentHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ParentHash", size, 32)
		return
	}
	dst = append(dst, h.ParentHash...)

	// Field (1) 'UncleHash'
	if size := len(h.UncleHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.UncleHash", size, 32)
		return
	}
	dst = append(dst, h.UncleHash...)

	// Field (2) 'Coinbase'
	if size := len(h.Coinbase); size != 20 {
		err = ssz.ErrBytesLengthFn("Header.Coinbase", size, 20)
		return
	}
	dst = append(dst, h.Coinbase...)

	// Field (3) 'Root'
	if size := len(h.Root); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Root", size, 32)
		return
	}
	dst = append(dst, h.Root...)

	// Field (4) 'TxHash'
	if size := len(h.TxHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.TxHash", size, 32)
		return
	}
	dst = append(dst, h.TxHash...)

	// Field (5) 'ReceiptHash'
	if size := len(h.ReceiptHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ReceiptHash", size, 32)
		return
	}
	dst = append(dst, h.ReceiptHash...)

	// Field (6) 'Bloom'
	if size := len(h.Bloom); size != 256 {
		err = ssz.ErrBytesLengthFn("Header.Bloom", size, 256)
		return
	}
	dst = append(dst, h.Bloom...)

	// Field (7) 'Difficulty'
	if size := len(h.Difficulty); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Difficulty", size, 32)
		return
	}
	dst = append(dst, h.Difficulty...)

	// Field (8) 'Number'
	dst = ssz.MarshalUint64(dst, h.Number)

	// Field (9) 'GasLimit'
	dst = ssz.MarshalUint64(dst, h.GasLimit)

	// Field (10) 'GasUsed'
	dst = ssz.MarshalUint64(dst, h.GasUsed)

	// Field (11) 'Time'
	dst = ssz.MarshalUint64(dst, h.Time)

	// Offset (12) 'Extra'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(h.Extra)

	// Field (13) 'MixDigest'
	if size := len(h.MixDigest); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.MixDigest", size, 32)
		return
	}
	dst = append(dst, h.MixDigest...)

	// Field (14) 'Nonce'
	if size := len(h.Nonce); size != 8 {
		err = ssz.ErrBytesLengthFn("Header.Nonce", size, 8)
		return
	}
	dst = append(dst, h.Nonce...)

	// Field (15) 'BaseFee'
	if size := len(h.BaseFee); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.BaseFee", size, 32)
		return
	}
	dst = append(dst, h.BaseFee...)

	// Field (16) 'WithdrawalsHash'
	if size := len(h.WithdrawalsHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.WithdrawalsHash", size, 32)
		return
	}
	dst = append(dst, h.WithdrawalsHash...)

	// Field (12) 'Extra'
	if size := len(h.Extra); size > 32 {
		err = ssz.ErrBytesLengthFn("Header.Extra", size, 32)
		return
	}
	dst = append(dst, h.Extra...)

	return
}

// UnmarshalSSZ ssz unmarshals the Header object
func (h *Header) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 608 {
		return ssz.ErrSize
	}

	tail := buf
	var o12 uint64

	// Field (0) 'ParentHash'
	if cap(h.ParentHash) == 0 {
		h.ParentHash = make([]byte, 0, len(buf[0:32]))
	}
	h.ParentHash = append(h.ParentHash, buf[0:32]...)

	// Field (1) 'UncleHash'
	if cap(h.UncleHash) == 0 {
		h.UncleHash = make([]byte, 0, len(buf[32:64]))
	}
	h.UncleHash = append(h.UncleHash, buf[32:64]...)

	// Field (2) 'Coinbase'
	if cap(h.Coinbase) == 0 {
		h.Coinbase = make([]byte, 0, len(buf[64:84]))
	}
	h.Coinbase = append(h.Coinbase, buf[64:84]...)

	// Field (3) 'Root'
	if cap(h.Root) == 0 {
		h.Root = make([]byte, 0, len(buf[84:116]))
	}
	h.Root = append(h.Root, buf[84:116]...)

	// Field (4) 'TxHash'
	if cap(h.TxHash) == 0 {
		h.TxHash = make([]byte, 0, len(buf[116:148]))
	}
	h.TxHash = append(h.TxHash, buf[116:148]...)

	// Field (5) 'ReceiptHash'
	if cap(h.ReceiptHash) == 0 {
		h.ReceiptHash = make([]byte, 0, len(buf[148:180]))
	}
	h.ReceiptHash = append(h.ReceiptHash, buf[148:180]...)

	// Field (6) 'Bloom'
	if cap(h.Bloom) == 0 {
		h.Bloom = make([]byte, 0, len(buf[180:436]))
	}
	h.Bloom = append(h.Bloom, buf[180:436]...)

	// Field (7) 'Difficulty'
	if cap(h.Difficulty) == 0 {
		h.Difficulty = make([]byte, 0, len(buf[436:468]))
	}
	h.Difficulty = append(h.Difficulty, buf[436:468]...)

	// Field (8) 'Number'
	h.Number = ssz.UnmarshallUint64(buf[468:476])

	// Field (9) 'GasLimit'
	h.GasLimit = ssz.UnmarshallUint64(buf[476:484])

	// Field (10) 'GasUsed'
	h.GasUsed = ssz.UnmarshallUint64(buf[484:492])

	// Field (11) 'Time'
	h.Time = ssz.UnmarshallUint64(buf[492:500])

	// Offset (12) 'Extra'
	if o12 = ssz.ReadOffset(buf[500:504]); o12 > size {
		return ssz.ErrOffset
	}

	if o12 < 608 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (13) 'MixDigest'
	if cap(h.MixDigest) == 0 {
		h.MixDigest = make([]byte, 0, len(buf[504:536]))
	}
	h.MixDigest = append(h.MixDigest, buf[504:536]...)

	// Field (14) 'Nonce'
	if cap(h.Nonce) == 0 {
		h.Nonce = make([]byte, 0, len(buf[536:544]))
	}
	h.Nonce = append(h.Nonce, buf[536:544]...)

	// Field (15) 'BaseFee'
	if cap(h.BaseFee) == 0 {
		h.BaseFee = make([]byte, 0, len(buf[544:576]))
	}
	h.BaseFee = append(h.BaseFee, buf[544:576]...)

	// Field (16) 'WithdrawalsHash'
	if cap(h.WithdrawalsHash) == 0 {
		h.WithdrawalsHash = make([]byte, 0, len(buf[576:608]))
	}
	h.WithdrawalsHash = append(h.WithdrawalsHash, buf[576:608]...)

	// Field (12) 'Extra'
	{
		buf = tail[o12:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(h.Extra) == 0 {
			h.Extra = make([]byte, 0, len(buf))
		}
		h.Extra = append(h.Extra, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Header object
func (h *Header) SizeSSZ() (size int) {
	size = 608

	// Field (12) 'Extra'
	size += len(h.Extra)

	return
}

// HashTreeRoot ssz hashes the Header object
func (h *Header) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the Header object with a hasher
func (h *Header) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ParentHash'
	if size := len(h.ParentHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ParentHash", size, 32)
		return
	}
	hh.PutBytes(h.ParentHash)

	// Field (1) 'UncleHash'
	if size := len(h.UncleHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.UncleHash", size, 32)
		return
	}
	hh.PutBytes(h.UncleHash)

	// Field (2) 'Coinbase'
	if size := len(h.Coinbase); size != 20 {
		err = ssz.ErrBytesLengthFn("Header.Coinbase", size, 20)
		return
	}
	hh.PutBytes(h.Coinbase)

	// Field (3) 'Root'
	if size := len(h.Root); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Root", size, 32)
		return
	}
	hh.PutBytes(h.Root)

	// Field (4) 'TxHash'
	if size := len(h.TxHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.TxHash", size, 32)
		return
	}
	hh.PutBytes(h.TxHash)

	// Field (5) 'ReceiptHash'
	if size := len(h.ReceiptHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ReceiptHash", size, 32)
		return
	}
	hh.PutBytes(h.ReceiptHash)

	// Field (6) 'Bloom'
	if size := len(h.Bloom); size != 256 {
		err = ssz.ErrBytesLengthFn("Header.Bloom", size, 256)
		return
	}
	hh.PutBytes(h.Bloom)

	// Field (7) 'Difficulty'
	if size := len(h.Difficulty); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Difficulty", size, 32)
		return
	}
	hh.PutBytes(h.Difficulty)

	// Field (8) 'Number'
	hh.PutUint64(h.Number)

	// Field (9) 'GasLimit'
	hh.PutUint64(h.GasLimit)

	// Field (10) 'GasUsed'
	hh.PutUint64(h.GasUsed)

	// Field (11) 'Time'
	hh.PutUint64(h.Time)

	// Field (12) 'Extra'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(h.Extra))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(h.Extra)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (13) 'MixDigest'
	if size := len(h.MixDigest); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.MixDigest", size, 32)
		return
	}
	hh.PutBytes(h.MixDigest)

	// Field (14) 'Nonce'
	if size := len(h.Nonce); size != 8 {
		err = ssz.ErrBytesLengthFn("Header.Nonce", size, 8)
		return
	}
	hh.PutBytes(h.Nonce)

	// Field (15) 'BaseFee'
	if size := len(h.BaseFee); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.BaseFee", size, 32)
		return
	}
	hh.PutBytes(h.BaseFee)

	// Field (16) 'WithdrawalsHash'
	if size := len(h.WithdrawalsHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.WithdrawalsHash", size, 32)
		return
	}
	hh.PutBytes(h.WithdrawalsHash)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Header object
func (h *Header) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}
